<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (17) -->
<title>SpeckCipher (juniper 0.6.9 API)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: package: com.github.tommyettinger.random.cipher, class: SpeckCipher">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">com.github.tommyettinger.random.cipher</a></div>
<h1 title="Class SpeckCipher" class="title">Class SpeckCipher</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">com.github.tommyettinger.random.cipher.SpeckCipher</div>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="modifiers">public final class </span><span class="element-name type-name-label">SpeckCipher</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block">An implementation of the <a href="https://en.wikipedia.org/wiki/Speck_(cipher)">Speck Cipher</a> that can encrypt
 and decrypt using either CBC or CTR modes. Speck is designed to be small and fast when implemented in software.
 This does not extend <code>javax.crypto.Cipher</code> because that isn't possible in a pure Java library, to my knowledge.
 <br>
 I have very little faith in my implementation's accuracy, and even an accurate implementation would have been
 specified by The United States of America's NSA, making it inherently untrustworthy. It should be fast, though,
 and strong enough to keep small-time crooks out of encrypted files. Big-time crooks (nation-states) should be
 assumed to already have anything they want that was encrypted with this.
 <br>
 This uses a block size of 128 bits and a key size of 256 bits.
 <br>
 The implementation here is based on <a href="https://github.com/m2mi/open_speck/blob/master/open-speck/src/main/c/speck.c">m2mi's open_speck C code</a>,
 which is licensed under Apache 2.0. Though the m2mi implementation seems to use some form of PKCS#7 for padding, it
 encrypts the last block but doesn't decrypt it, so I think it may only work when a full block of padding is written,
 validated and ignored. That is, if it works at all! I haven't been able to test m2mi's implementation, but this
 code has been tested some in this repo. This version uses zero-padding instead of PKCS#7, and works even if a
 partial block is all there is in the plaintext. When encrypting with CBC mode, the ciphertext array may need to be
 larger than the plaintext array; use <a href="#newPaddedArray(long%5B%5D)"><code>newPaddedArray(long[])</code></a> or <a href="#newPaddedArray(byte%5B%5D)"><code>newPaddedArray(byte[])</code></a> to get an
 array of the right size. This isn't required for CTR mode.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decrypt(long%5B%5D,byte%5B%5D,int,byte%5B%5D,int)" class="member-name-link">decrypt</a><wbr>(long[]&nbsp;key,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A usually-internal decryption step.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decrypt(long%5B%5D,long%5B%5D,int,long%5B%5D,int)" class="member-name-link">decrypt</a><wbr>(long[]&nbsp;key,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A usually-internal decryption step.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)" class="member-name-link">decryptCBC</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)" class="member-name-link">decryptCBC</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to decrypt a coded "ciphertext" long array and get back the original "plaintext"
 long array from before <a href="#encryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a>
 was called.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)" class="member-name-link">decryptCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to decrypt a coded "ciphertext" byte array and get back a "plaintext" byte array.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptCTR(long,long,long,long,long,int,byte%5B%5D,int,byte%5B%5D,int,int)" class="member-name-link">decryptCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 int&nbsp;nonce2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to decrypt a coded "ciphertext" byte array and get back a "plaintext" byte array.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)" class="member-name-link">decryptCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to decrypt a coded "ciphertext" long array and get back a "plaintext" long array.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptInPlaceCTR(long,long,long,long,long,byte%5B%5D,int,int)" class="member-name-link">decryptInPlaceCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decrypts a coded "ciphertext" byte array and changes it in-place to a "plaintext" byte array.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#decryptInPlaceCTR(long,long,long,long,long,java.nio.ByteBuffer,int,int)" class="member-name-link">decryptInPlaceCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Decrypts a coded "ciphertext" ByteBuffer and changes it in-place to a "plaintext" ByteBuffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encrypt(long%5B%5D,long,long,byte%5B%5D,int,byte%5B%5D,int)" class="member-name-link">encrypt</a><wbr>(long[]&nbsp;key,
 long&nbsp;last0,
 long&nbsp;last1,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A usually-internal encryption step.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encrypt(long%5B%5D,long,long,long%5B%5D,int,long%5B%5D,int)" class="member-name-link">encrypt</a><wbr>(long[]&nbsp;key,
 long&nbsp;last0,
 long&nbsp;last1,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A usually-internal encryption step.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)" class="member-name-link">encryptCBC</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)" class="member-name-link">encryptCBC</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to encrypt a "plaintext" long array and get back a coded "ciphertext" long array.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)" class="member-name-link">encryptCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptCTR(long,long,long,long,long,int,byte%5B%5D,int,byte%5B%5D,int,int)" class="member-name-link">encryptCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 int&nbsp;nonce2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)" class="member-name-link">encryptCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">One of the main ways here to encrypt a "plaintext" long array and get back a coded "ciphertext" long array.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptInPlaceCTR(long,long,long,long,long,byte%5B%5D,int,int)" class="member-name-link">encryptInPlaceCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Encrypts a "plaintext" byte array in-place, making it a coded "ciphertext" byte array.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptInPlaceCTR(long,long,long,long,long,java.nio.ByteBuffer,int,int)" class="member-name-link">encryptInPlaceCTR</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;plaintext,
 int&nbsp;plainOffset,
 int&nbsp;textLength)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Encrypts a "plaintext" ByteBuffer in-place, making it a coded "ciphertext" ByteBuffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptWithXor(long%5B%5D,long,long,byte%5B%5D,int)" class="member-name-link">encryptWithXor</a><wbr>(long[]&nbsp;key,
 long&nbsp;iv0,
 long&nbsp;iv1,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A usually-internal encryption step.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#encryptWithXor(long%5B%5D,long,long,java.nio.ByteBuffer,int)" class="member-name-link">encryptWithXor</a><wbr>(long[]&nbsp;key,
 long&nbsp;iv0,
 long&nbsp;iv1,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;plaintext,
 int&nbsp;plainOffset)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">A usually-internal encryption step.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#expandKey(long,long,long,long)" class="member-name-link">expandKey</a><wbr>(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Given a 256-bit key as four long values, this grows that initial key into a 2176-bit expanded key (a
 <code>long[34]</code>).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static byte[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#newPaddedArray(byte%5B%5D)" class="member-name-link">newPaddedArray</a><wbr>(byte[]&nbsp;data)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Copies <code>data</code> into a new byte array that will be at least as long as data, padded with zeroes
 so that it meets a length that is a multiple of 16, if necessary.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static long[]</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#newPaddedArray(long%5B%5D)" class="member-name-link">newPaddedArray</a><wbr>(long[]&nbsp;data)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Copies <code>data</code> into a new long array that will be at least as long as data, padded with zeroes
 so that it meets a length that is a multiple of 2, if necessary.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="newPaddedArray(long[])">
<h3>newPaddedArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">newPaddedArray</span><wbr><span class="parameters">(long[]&nbsp;data)</span></div>
<div class="block">Copies <code>data</code> into a new long array that will be at least as long as data, padded with zeroes
 so that it meets a length that is a multiple of 2, if necessary. If data is null, this returns a new
 long array with length 2.
 <br>
 This is typically used to ensure the ciphertext array is long enough to hold the data assigned to it.
 It is only needed for the ciphertext written to by
 <a href="#encryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a> (CTR doesn't need it).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>data</code> - a long array to copy, potentially including padding in the copy</dd>
<dt>Returns:</dt>
<dd>a long array with a length that is a multiple of 2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="newPaddedArray(byte[])">
<h3>newPaddedArray</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">newPaddedArray</span><wbr><span class="parameters">(byte[]&nbsp;data)</span></div>
<div class="block">Copies <code>data</code> into a new byte array that will be at least as long as data, padded with zeroes
 so that it meets a length that is a multiple of 16, if necessary. If data is null, this returns a new
 byte array with length 16.
 <br>
 This is typically used to ensure the ciphertext array is long enough to hold the data assigned to it.
 It is only needed for the ciphertext written to by
 <a href="#encryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, byte[], int, byte[], int, int)</code></a> (CTR doesn't need it).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>data</code> - a byte array to copy, potentially including padding in the copy</dd>
<dt>Returns:</dt>
<dd>a byte array with a length that is a multiple of 16</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="expandKey(long,long,long,long)">
<h3>expandKey</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">expandKey</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4)</span></div>
<div class="block">Given a 256-bit key as four long values, this grows that initial key into a 2176-bit expanded key (a
 <code>long[34]</code>). This uses 34 rounds of the primary algorithm used by Speck.
 Used by <a href="#encryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a>, <a href="#encryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, long[], int, long[], int, int)</code></a>, <a href="#decryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>decryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a>, and <a href="#decryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>decryptCTR(long, long, long, long, long, long[], int, long[], int, int)</code></a> internally.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dt>Returns:</dt>
<dd>a 34-item long array that should, of course, be kept secret to be used cryptographically</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encrypt(long[],long,long,long[],int,long[],int)">
<h3>encrypt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">encrypt</span><wbr><span class="parameters">(long[]&nbsp;key,
 long&nbsp;last0,
 long&nbsp;last1,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</span></div>
<div class="block">A usually-internal encryption step. You should use either CBC or CTR mode to actually encrypt a piece of
 plaintext, with <a href="#encryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a> or
 <a href="#encryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, long[], int, long[], int, int)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>key</code> - an expanded key, as produced by <a href="#expandKey(long,long,long,long)"><code>expandKey(long, long, long, long)</code></a></dd>
<dd><code>last0</code> - the first half of the previous result, or the first IV if there was no previous result</dd>
<dd><code>last1</code> - the last half of the previous result, or the second IV if there was no previous result</dd>
<dd><code>plaintext</code> - the plaintext array, as long items</dd>
<dd><code>plainOffset</code> - the index to start reading from in plaintext</dd>
<dd><code>ciphertext</code> - the ciphertext array, as long items that will be written to; <a href="#newPaddedArray(long%5B%5D)"><code>may need to be padded</code></a></dd>
<dd><code>cipherOffset</code> - the index to start writing to in ciphertext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encrypt(long[],long,long,byte[],int,byte[],int)">
<h3>encrypt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">encrypt</span><wbr><span class="parameters">(long[]&nbsp;key,
 long&nbsp;last0,
 long&nbsp;last1,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</span></div>
<div class="block">A usually-internal encryption step. You should use either CBC or CTR mode to actually encrypt a piece of
 plaintext, with <a href="#encryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, byte[], int, byte[], int, int)</code></a>  or
 <a href="#encryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, byte[], int, byte[], int, int)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>key</code> - an expanded key, as produced by <a href="#expandKey(long,long,long,long)"><code>expandKey(long, long, long, long)</code></a></dd>
<dd><code>last0</code> - the first half of the previous result, or the first IV if there was no previous result</dd>
<dd><code>last1</code> - the last half of the previous result, or the second IV if there was no previous result</dd>
<dd><code>plaintext</code> - the plaintext array, as byte items</dd>
<dd><code>plainOffset</code> - the index to start reading from in plaintext</dd>
<dd><code>ciphertext</code> - the ciphertext array, as byte items that will be written to; <a href="#newPaddedArray(byte%5B%5D)"><code>may need to be padded</code></a></dd>
<dd><code>cipherOffset</code> - the index to start writing to in ciphertext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptWithXor(long[],long,long,byte[],int)">
<h3>encryptWithXor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">encryptWithXor</span><wbr><span class="parameters">(long[]&nbsp;key,
 long&nbsp;iv0,
 long&nbsp;iv1,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset)</span></div>
<div class="block">A usually-internal encryption step. You should use either CBC or CTR mode to actually encrypt a piece of
 plaintext, with <a href="#encryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, byte[], int, byte[], int, int)</code></a>  or
 <a href="#encryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, byte[], int, byte[], int, int)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>key</code> - an expanded key, as produced by <a href="#expandKey(long,long,long,long)"><code>expandKey(long, long, long, long)</code></a></dd>
<dd><code>iv0</code> - the first IV</dd>
<dd><code>iv1</code> - the second IV</dd>
<dd><code>plaintext</code> - the plaintext array, as byte items; will be modified</dd>
<dd><code>plainOffset</code> - the index to start writing to (with XOR) in plaintext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptWithXor(long[],long,long,java.nio.ByteBuffer,int)">
<h3>encryptWithXor</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">encryptWithXor</span><wbr><span class="parameters">(long[]&nbsp;key,
 long&nbsp;iv0,
 long&nbsp;iv1,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;plaintext,
 int&nbsp;plainOffset)</span></div>
<div class="block">A usually-internal encryption step. You should use either CBC or CTR mode to actually encrypt a piece of
 plaintext, with <a href="#encryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, byte[], int, byte[], int, int)</code></a>  or
 <a href="#encryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, byte[], int, byte[], int, int)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>key</code> - an expanded key, as produced by <a href="#expandKey(long,long,long,long)"><code>expandKey(long, long, long, long)</code></a></dd>
<dd><code>iv0</code> - the first IV</dd>
<dd><code>iv1</code> - the second IV</dd>
<dd><code>plaintext</code> - the plaintext array, as byte items; will be modified</dd>
<dd><code>plainOffset</code> - the index to start writing to (with XOR) in plaintext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decrypt(long[],long[],int,long[],int)">
<h3>decrypt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">decrypt</span><wbr><span class="parameters">(long[]&nbsp;key,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</span></div>
<div class="block">A usually-internal decryption step. You should use either CBC or CTR mode to actually decrypt a piece of
 plaintext, with <a href="#decryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>decryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a> or
 <a href="#decryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>decryptCTR(long, long, long, long, long, long[], int, long[], int, int)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>key</code> - an expanded key, as produced by <a href="#expandKey(long,long,long,long)"><code>expandKey(long, long, long, long)</code></a></dd>
<dd><code>plaintext</code> - the plaintext array, as long items that will be written to</dd>
<dd><code>plainOffset</code> - the index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the ciphertext array, as long items</dd>
<dd><code>cipherOffset</code> - the index to start reading from in ciphertext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decrypt(long[],byte[],int,byte[],int)">
<h3>decrypt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">decrypt</span><wbr><span class="parameters">(long[]&nbsp;key,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset)</span></div>
<div class="block">A usually-internal decryption step. You should use either CBC or CTR mode to actually decrypt a piece of
 plaintext, with <a href="#decryptCBC(long,long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>decryptCBC(long, long, long, long, long, long, byte[], int, byte[], int, int)</code></a>  or
 <a href="#decryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>decryptCTR(long, long, long, long, long, byte[], int, byte[], int, int)</code></a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>key</code> - an expanded key, as produced by <a href="#expandKey(long,long,long,long)"><code>expandKey(long, long, long, long)</code></a></dd>
<dd><code>plaintext</code> - the plaintext array, as byte items that will be written to</dd>
<dd><code>plainOffset</code> - the index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the ciphertext array, as byte items</dd>
<dd><code>cipherOffset</code> - the index to start reading from in ciphertext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptCBC(long,long,long,long,long,long,long[],int,long[],int,int)">
<h3>encryptCBC</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">encryptCBC</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to encrypt a "plaintext" long array and get back a coded "ciphertext" long array.
 This takes four <code>long</code>s as its key (256-bits), and also requires two unique (never used again) longs
 as IVs. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate IVs, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless IVs are requested for years from one generator, so it is a good
 option to produce IVs (using two DistinctRandom generators also works, with one for each IV). The rest of the
 arguments are about the data being encrypted. The plaintext is the long array to encrypt; it will not be
 modified here. The plainOffset is which index in plaintext to start reading from. The ciphertext will be written
 to, should usually be empty at the start (though it doesn't need to be), and must be padded as by
 <a href="#newPaddedArray(long%5B%5D)"><code>newPaddedArray(long[])</code></a>. The cipheroffset is which index to start writing to in ciphertext. Lastly, the
 textLength is how many long items to encrypt from plaintext; this can be less than plaintext's length.
 <br>
 This uses CBC mode, so it takes two IVs instead of how CTR mode takes one nonce. If the IVs aren't sufficiently
 random, this produces higher-quality outputs than CTR mode. CBC mode may be slightly faster, though this isn't
 clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>iv1</code> - a long that must never be reused as iv1 again under the same key; needed to decrypt</dd>
<dd><code>iv2</code> - a long that must never be reused as iv2 again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the long array to encrypt; will not be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from plaintext</dd>
<dd><code>ciphertext</code> - the long array to write encrypted data to; will be modified, and should be padded</dd>
<dd><code>cipherOffset</code> - which index to start writing to in ciphertext</dd>
<dd><code>textLength</code> - how many long items to read and encrypt from plaintext</dd>
<dt>Returns:</dt>
<dd>ciphertext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptCBC(long,long,long,long,long,long,byte[],int,byte[],int,int)">
<h3>encryptCBC</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">encryptCBC</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires two unique (never used again) longs
 as IVs. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate IVs, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless IVs are requested for years from one generator, so it is a good
 option to produce IVs (using two DistinctRandom generators also works, with one for each IV). The rest of the
 arguments are about the data being encrypted. The plaintext is the byte array to encrypt; it will not be
 modified here. The plainOffset is which index in plaintext to start reading from. The ciphertext will be written
 to, should usually be empty at the start (though it doesn't need to be), and must be padded as by
 <a href="#newPaddedArray(byte%5B%5D)"><code>newPaddedArray(byte[])</code></a>. The cipheroffset is which index to start writing to in ciphertext. Lastly, the
 textLength is how many byte items to encrypt from plaintext; this can be less than plaintext's length.
 <br>
 This uses CBC mode, so it takes two IVs instead of how CTR mode takes one nonce. If the IVs aren't sufficiently
 random, this produces higher-quality outputs than CTR mode. CBC mode may be slightly faster, though this isn't
 clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>iv1</code> - a long that must never be reused as iv1 again under the same key; needed to decrypt</dd>
<dd><code>iv2</code> - a long that must never be reused as iv2 again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the byte array to encrypt; will not be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from plaintext</dd>
<dd><code>ciphertext</code> - the byte array to write encrypted data to; will be modified, and should be padded</dd>
<dd><code>cipherOffset</code> - which index to start writing to in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and encrypt from plaintext</dd>
<dt>Returns:</dt>
<dd>ciphertext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptCBC(long,long,long,long,long,long,long[],int,long[],int,int)">
<h3>decryptCBC</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">decryptCBC</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to decrypt a coded "ciphertext" long array and get back the original "plaintext"
 long array from before <a href="#encryptCBC(long,long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCBC(long, long, long, long, long, long, long[], int, long[], int, int)</code></a>
 was called.
 This takes four <code>long</code>s as its key (256-bits), and also requires two unique (never used again) longs
 as IVs. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate IVs, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless IVs are requested for years from one generator, so it is a good
 option to produce IVs (using two DistinctRandom generators also works, with one for each IV). The rest of the
 arguments are about the data being encrypted. The plaintext is the long array to receive decrypted data; it will
 be modified, but doesn't have size restrictions. The plainOffset is which index in plaintext to start writing to.
 The ciphertext will only be read from here, and should start with the output of encryptCBC(). The cipheroffset is
 which index to start reading from in ciphertext. Lastly, the textLength is how many long items to decrypt from
 ciphertext; this must be at least equal to plaintext's length.
 <br>
 This uses CBC mode, so it takes two IVs instead of how CTR mode takes one nonce. If the IVs aren't sufficiently
 random, this produces higher-quality outputs than CTR mode. CBC mode may be slightly faster, though this isn't
 clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength to be a multiple
 of 2 (16 bytes) when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>iv1</code> - a long that was used as iv1 to encrypt this specific data</dd>
<dd><code>iv2</code> - a long that was used as iv2 to encrypt this specific data</dd>
<dd><code>plaintext</code> - the long array to write to</dd>
<dd><code>plainOffset</code> - which index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the long array to read coded data from</dd>
<dd><code>cipherOffset</code> - which index to start reading from in ciphertext</dd>
<dd><code>textLength</code> - how many long items to read from ciphertext</dd>
<dt>Returns:</dt>
<dd>plaintext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptCBC(long,long,long,long,long,long,byte[],int,byte[],int,int)">
<h3>decryptCBC</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">decryptCBC</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;iv1,
 long&nbsp;iv2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being encrypted. The plaintext is the
 byte array to encrypt; it will not be modified here. The plainOffset is which index in plaintext to start reading
 from. The ciphertext is the byte array that will be written to, and should usually be empty at the start (though
 it doesn't need to be). The ciphertext does not need to be padded (it does for CBC mode). The cipheroffset is
 which index to start writing to in ciphertext. Lastly, the textLength is how many byte items to encrypt from
 plaintext; this can be less than plaintext's length.
 <br>
 This uses CBC mode, so it takes two IVs instead of how CTR mode takes one nonce. If the IVs aren't sufficiently
 random, this produces higher-quality outputs than CTR mode. CBC mode may be slightly faster, though this isn't
 clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength to be a multiple of
 16 when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>iv1</code> - a long that was used as iv1 to encrypt this specific data</dd>
<dd><code>iv2</code> - a long that was used as iv2 to encrypt this specific data</dd>
<dd><code>plaintext</code> - the byte array to write to</dd>
<dd><code>plainOffset</code> - which index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the byte array to read coded data from</dd>
<dd><code>cipherOffset</code> - which index to start reading from in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read from ciphertext</dd>
<dt>Returns:</dt>
<dd>plaintext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptCTR(long,long,long,long,long,long[],int,long[],int,int)">
<h3>encryptCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">encryptCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to encrypt a "plaintext" long array and get back a coded "ciphertext" long array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being encrypted. The plaintext is the
 long array to encrypt; it will not be modified here. The plainOffset is which index in plaintext to start reading
 from. The ciphertext is the long array that will be written to, and should usually be empty at the start (though
 it doesn't need to be). The ciphertext does not need to be padded (it does for CBC mode). The cipheroffset is
 which index to start writing to in ciphertext. Lastly, the textLength is how many long items to encrypt from
 plaintext; this can be less than plaintext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that must never be reused as nonce again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the long array to encrypt; will not be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from plaintext</dd>
<dd><code>ciphertext</code> - the long array to write encrypted data to; will be modified</dd>
<dd><code>cipherOffset</code> - which index to start writing to in ciphertext</dd>
<dd><code>textLength</code> - how many long items to read and encrypt from plaintext</dd>
<dt>Returns:</dt>
<dd>ciphertext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptCTR(long,long,long,long,long,byte[],int,byte[],int,int)">
<h3>encryptCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">encryptCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being encrypted. The plaintext is the
 byte array to encrypt; it will not be modified here. The plainOffset is which index in plaintext to start reading
 from. The ciphertext is the byte array that will be written to, and should usually be empty at the start (though
 it doesn't need to be). The ciphertext does not need to be padded (it does for CBC mode). The cipheroffset is
 which index to start writing to in ciphertext. Lastly, the textLength is how many byte items to encrypt from
 plaintext; this can be less than plaintext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that must never be reused as nonce again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the byte array to encrypt; will not be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from plaintext</dd>
<dd><code>ciphertext</code> - the byte array to write encrypted data to; will be modified</dd>
<dd><code>cipherOffset</code> - which index to start writing to in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and encrypt from plaintext</dd>
<dt>Returns:</dt>
<dd>ciphertext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptCTR(long,long,long,long,long,int,byte[],int,byte[],int,int)">
<h3>encryptCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">encryptCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 int&nbsp;nonce2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to encrypt a "plaintext" byte array and get back a coded "ciphertext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being encrypted. The plaintext is the
 byte array to encrypt; it will not be modified here. The plainOffset is which index in plaintext to start reading
 from. The ciphertext is the byte array that will be written to, and should usually be empty at the start (though
 it doesn't need to be). The ciphertext does not need to be padded (it does for CBC mode). The cipheroffset is
 which index to start writing to in ciphertext. Lastly, the textLength is how many byte items to encrypt from
 plaintext; this can be less than plaintext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that must never be reused as nonce again under the same key; needed to decrypt</dd>
<dd><code>nonce2</code> - an int that must never be reused as nonce2 again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the byte array to encrypt; will not be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from plaintext</dd>
<dd><code>ciphertext</code> - the byte array to write encrypted data to; will be modified</dd>
<dd><code>cipherOffset</code> - which index to start writing to in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and encrypt from plaintext</dd>
<dt>Returns:</dt>
<dd>ciphertext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptCTR(long,long,long,long,long,long[],int,long[],int,int)">
<h3>decryptCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">long[]</span>&nbsp;<span class="element-name">decryptCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 long[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 long[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to decrypt a coded "ciphertext" long array and get back a "plaintext" long array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being decrypted. The plaintext is the
 long array that will receive the decrypted final result. The plainOffset is which index in plaintext to start
 writing to. The ciphertext is the long array that contains coded data, and should have been encrypted by
 <a href="#encryptCTR(long,long,long,long,long,long%5B%5D,int,long%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, long[], int, long[], int, int)</code></a>. The ciphertext does not need to
 be padded (it does for CBC mode). The cipheroffset is which index to start reading from in ciphertext. Lastly,
 the textLength is how many long items to decrypt from ciphertext; this can be less than ciphertext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength
 to be a multiple of 2 (16 bytes) when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that was used as nonce to encrypt this specific data</dd>
<dd><code>plaintext</code> - the long array to receive decrypted data; will be modified</dd>
<dd><code>plainOffset</code> - which index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the long array to read encrypted data from; will not be modified</dd>
<dd><code>cipherOffset</code> - which index to start reading from in ciphertext</dd>
<dd><code>textLength</code> - how many long items to read and decrypt from ciphertext</dd>
<dt>Returns:</dt>
<dd>plaintext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptCTR(long,long,long,long,long,byte[],int,byte[],int,int)">
<h3>decryptCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">decryptCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to decrypt a coded "ciphertext" byte array and get back a "plaintext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being decrypted. The plaintext is the
 byte array that will receive the decrypted final result. The plainOffset is which index in plaintext to start
 writing to. The ciphertext is the byte array that contains coded data, and should have been encrypted by
 <a href="#encryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, byte[], int, byte[], int, int)</code></a>. The ciphertext does not need to
 be padded (it does for CBC mode). The cipheroffset is which index to start reading from in ciphertext. Lastly,
 the textLength is how many byte items to decrypt from ciphertext; this can be less than ciphertext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength
 to be a multiple of 16 when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that was used as nonce to encrypt this specific data</dd>
<dd><code>plaintext</code> - the byte array to receive decrypted data; will be modified</dd>
<dd><code>plainOffset</code> - which index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the byte array to read encrypted data from; will not be modified</dd>
<dd><code>cipherOffset</code> - which index to start reading from in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and decrypt from ciphertext</dd>
<dt>Returns:</dt>
<dd>plaintext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptCTR(long,long,long,long,long,int,byte[],int,byte[],int,int)">
<h3>decryptCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">decryptCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 int&nbsp;nonce2,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">One of the main ways here to decrypt a coded "ciphertext" byte array and get back a "plaintext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being decrypted. The plaintext is the
 byte array that will receive the decrypted final result. The plainOffset is which index in plaintext to start
 writing to. The ciphertext is the byte array that contains coded data, and should have been encrypted by
 <a href="#encryptCTR(long,long,long,long,long,byte%5B%5D,int,byte%5B%5D,int,int)"><code>encryptCTR(long, long, long, long, long, byte[], int, byte[], int, int)</code></a>. The ciphertext does not need to
 be padded (it does for CBC mode). The cipheroffset is which index to start reading from in ciphertext. Lastly,
 the textLength is how many byte items to decrypt from ciphertext; this can be less than ciphertext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength
 to be a multiple of 16 when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that was used as nonce to encrypt this specific data</dd>
<dd><code>nonce2</code> - an int that was used as nonce2 to encrypt this specific data</dd>
<dd><code>plaintext</code> - the byte array to receive decrypted data; will be modified</dd>
<dd><code>plainOffset</code> - which index to start writing to in plaintext</dd>
<dd><code>ciphertext</code> - the byte array to read encrypted data from; will not be modified</dd>
<dd><code>cipherOffset</code> - which index to start reading from in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and decrypt from ciphertext</dd>
<dt>Returns:</dt>
<dd>plaintext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptInPlaceCTR(long,long,long,long,long,byte[],int,int)">
<h3>encryptInPlaceCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">encryptInPlaceCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;plaintext,
 int&nbsp;plainOffset,
 int&nbsp;textLength)</span></div>
<div class="block">Encrypts a "plaintext" byte array in-place, making it a coded "ciphertext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being encrypted. The plaintext is the
 byte array to encrypt; it will be modified here. The plainOffset is which index in plaintext to start reading
 from and writing to. Lastly, the textLength is how many byte items to encrypt from
 plaintext; this can be less than plaintext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that must never be reused as nonce again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the byte array to encrypt in-place; will be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from and writing to in plaintext</dd>
<dd><code>textLength</code> - how many byte items to read and encrypt from plaintext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptInPlaceCTR(long,long,long,long,long,byte[],int,int)">
<h3>decryptInPlaceCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">byte[]</span>&nbsp;<span class="element-name">decryptInPlaceCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 byte[]&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">Decrypts a coded "ciphertext" byte array and changes it in-place to a "plaintext" byte array.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being decrypted. The ciphertext is the
 byte array that contains coded data, and should have been encrypted by
 <a href="#encryptInPlaceCTR(long,long,long,long,long,byte%5B%5D,int,int)"><code>encryptInPlaceCTR(long, long, long, long, long, byte[], int, int)</code></a>. The ciphertext will be modified
 in-place to become the plaintext. The cipheroffset is which index to start reading from in ciphertext. Lastly,
 the textLength is how many byte items to decrypt from ciphertext; this can be less than ciphertext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength
 to be a multiple of 16 when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that was used as nonce to encrypt this specific data</dd>
<dd><code>ciphertext</code> - the byte array to read encrypted data from; will be modified in-place</dd>
<dd><code>cipherOffset</code> - which index to start reading from and writing to in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and decrypt from ciphertext</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="encryptInPlaceCTR(long,long,long,long,long,java.nio.ByteBuffer,int,int)">
<h3>encryptInPlaceCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a></span>&nbsp;<span class="element-name">encryptInPlaceCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;plaintext,
 int&nbsp;plainOffset,
 int&nbsp;textLength)</span></div>
<div class="block">Encrypts a "plaintext" ByteBuffer in-place, making it a coded "ciphertext" ByteBuffer.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being encrypted. The plaintext is the
 ByteBuffer to encrypt; it will be modified here. The plainOffset is which index in plaintext to start reading
 from and writing to. Lastly, the textLength is how many byte items to encrypt from
 plaintext; this can be less than plaintext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that must never be reused as nonce again under the same key; needed to decrypt</dd>
<dd><code>plaintext</code> - the ByteBuffer to encrypt in-place; will be modified</dd>
<dd><code>plainOffset</code> - which index to start reading from and writing to in plaintext</dd>
<dd><code>textLength</code> - how many byte items to read and encrypt from plaintext</dd>
<dt>Returns:</dt>
<dd>plaintext, after modifications</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="decryptInPlaceCTR(long,long,long,long,long,java.nio.ByteBuffer,int,int)">
<h3>decryptInPlaceCTR</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a></span>&nbsp;<span class="element-name">decryptInPlaceCTR</span><wbr><span class="parameters">(long&nbsp;k1,
 long&nbsp;k2,
 long&nbsp;k3,
 long&nbsp;k4,
 long&nbsp;nonce,
 <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;ciphertext,
 int&nbsp;cipherOffset,
 int&nbsp;textLength)</span></div>
<div class="block">Decrypts a coded "ciphertext" ByteBuffer and changes it in-place to a "plaintext" ByteBuffer.
 This takes four <code>long</code>s as its key (256-bits), and also requires one unique (never used again) long as
 the nonce. How you generate keys is up to you, but the keys must be kept secret for encryption to stay secure.
 To generate nonce, secrecy isn't as important as uniqueness; calling DistinctRandom.nextLong() even many
 times will never return the same long unless nonce are requested for years from one generator, so it is a good
 option to produce nonce data. The rest of the arguments are about the data being decrypted. The ciphertext is the
 ByteBuffer that contains coded data, and should have been encrypted by
 <a href="#encryptInPlaceCTR(long,long,long,long,long,java.nio.ByteBuffer,int,int)"><code>encryptInPlaceCTR(long, long, long, long, long, ByteBuffer, int, int)</code></a>. The ciphertext will be modified
 in-place to become the plaintext. The cipheroffset is which index to start reading from in ciphertext. Lastly,
 the textLength is how many byte items to decrypt from ciphertext; this can be less than ciphertext's length.
 <br>
 This uses CTR mode, so it takes one nonce instead of how CBC mode takes two IVs. If the IVs/nonce aren't
 sufficiently random, CBC mode produces higher-quality outputs than CTR mode. CBC mode may be slightly faster,
 though this isn't clear yet. CTR mode doesn't need its ciphertext to have padding. CBC mode requires textLength
 to be a multiple of 16 when decrypting (usually guaranteed by padding).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>k1</code> - a secret long; part of the key</dd>
<dd><code>k2</code> - a secret long; part of the key</dd>
<dd><code>k3</code> - a secret long; part of the key</dd>
<dd><code>k4</code> - a secret long; part of the key</dd>
<dd><code>nonce</code> - a long that was used as nonce to encrypt this specific data</dd>
<dd><code>ciphertext</code> - the ByteBuffer to read encrypted data from; will be modified in-place</dd>
<dd><code>cipherOffset</code> - which index to start reading from and writing to in ciphertext</dd>
<dd><code>textLength</code> - how many byte items to read and decrypt from ciphertext</dd>
<dt>Returns:</dt>
<dd>ciphertext, after modifications</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
